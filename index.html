<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Motion Sickness Guard</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #000000; /* 背景を完全な黒に */
            font-family: sans-serif;
            touch-action: none; /* 全体のスクロール防止 */
            color: white;
        }

        /* 画面全体の警告オーバーレイ */
        #global-warning {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.5);
            box-shadow: inset 0 0 100px red;
            z-index: 500;
            opacity: 0; 
            /* transitionはJSで動的に設定します */
            pointer-events: none;
            display: flex; align-items: center; justify-content: center;
        }
        #global-warning-text {
            color: white; font-size: 3rem; font-weight: bold;
            text-shadow: 0 0 10px black;
            text-align: center;
        }

        /* フローティングウィンドウ */
        #floating-window {
            position: absolute;
            top: 50px; left: 50px;
            width: 320px; height: 240px;
            min-width: 150px; min-height: 120px;
            background: #000;
            border: 2px solid #666;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(255,255,255,0.1);
            display: flex; flex-direction: column;
            overflow: hidden;
            z-index: 1000;
            cursor: move;
        }

        /* ヘッダー */
        #window-header {
            height: 30px;
            background: #007AFF;
            display: flex; align-items: center; padding: 0 10px;
            color: white; font-size: 12px; font-weight: bold;
            user-select: none;
            /* ドラッグ判定はウィンドウ全体で行うが、ボタン操作のためにポインターイベントは通す */
        }
        
        #settings-btn {
            background: none; border: none; cursor: pointer; font-size: 16px; padding: 0 10px;
            margin-left: 10px; pointer-events: auto; /* ここだけクリック可能にする */
        }

        /* カメラ表示エリア */
        #camera-container {
            flex: 1; position: relative; background: #000;
            pointer-events: none;
        }
        video {
            width: 100%; height: 100%; object-fit: cover;
        }

        /* リサイズハンドル */
        #resize-handle {
            position: absolute; bottom: 0; right: 0;
            width: 40px; height: 40px;
            background: linear-gradient(135deg, transparent 50%, #007AFF 50%);
            cursor: nwse-resize;
            z-index: 1100;
            touch-action: none;
        }

        /* 設定モーダル */
        #settings-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 3000;
            display: none; /* 初期状態は非表示 */
            align-items: center; justify-content: center;
        }
        #settings-panel {
            background: #222; padding: 20px; border-radius: 15px;
            width: 80%; max-width: 400px;
            border: 1px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .setting-item { margin-bottom: 20px; }
        .setting-label { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px;}
        input[type="range"] { width: 100%; accent-color: #007AFF; }
        
        #close-settings {
            width: 100%; padding: 10px; background: #444; color: white;
            border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;
        }

        /* スタート画面 */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white;
        }
        button.primary-btn {
            padding: 15px 30px; font-size: 1.2rem; background: #007AFF;
            color: white; border: none; border-radius: 50px; margin-top: 20px;
        }
        #debug-info { font-size: 10px; color: lime; margin-left: auto; pointer-events: auto; }
    </style>
</head>
<body>

    <!-- スタート画面 -->
    <div id="start-overlay">
        <h2>Motion Sickness Guard</h2>
        <p>Beam Pro 背面カメラを使用</p>
        <button id="start-btn" class="primary-btn">監視を開始</button>
    </div>

    <!-- 画面全体の警告 -->
    <div id="global-warning">
        <div id="global-warning-text">⚠️ 酔い注意 ⚠️<br>視線を外してください</div>
    </div>

    <!-- 設定モーダル -->
    <div id="settings-modal">
        <div id="settings-panel">
            <h3>設定</h3>
            
            <div class="setting-item">
                <div class="setting-label">
                    <span>景色検知の閾値 (感度)</span>
                    <span id="val-visual">15.0</span>
                </div>
                <input type="range" id="input-visual" min="1" max="50" step="1" value="15">
                <small style="color:#aaa;">小さいほど敏感になります</small>
            </div>

            <div class="setting-item">
                <div class="setting-label">
                    <span>警告フェード時間 (秒)</span>
                    <span id="val-fade">0.5s</span>
                </div>
                <input type="range" id="input-fade" min="0.1" max="5.0" step="0.1" value="0.5">
            </div>

            <button id="close-settings">閉じる</button>
        </div>
    </div>

    <!-- フローティングウィンドウ -->
    <div id="floating-window">
        <div id="window-header">
            <span>Camera</span>
            <!-- 設定ボタン -->
            <button id="settings-btn">⚙️</button>
            <div id="debug-info">Wait...</div>
        </div>

        <div id="camera-container">
            <video id="camera-view" autoplay playsinline muted></video>
        </div>

        <div id="resize-handle"></div>
    </div>

    <canvas id="proc-canvas" style="display:none;"></canvas>

    <script>
        // --- 要素取得 ---
        const win = document.getElementById('floating-window');
        const resizer = document.getElementById('resize-handle');
        const video = document.getElementById('camera-view');
        const globalWarning = document.getElementById('global-warning');
        const debugInfo = document.getElementById('debug-info');
        const startBtn = document.getElementById('start-btn');
        const startOverlay = document.getElementById('start-overlay');
        const canvas = document.getElementById('proc-canvas');
        const ctx = canvas.getContext('2d');
        
        // 設定関連要素
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings');
        const inputVisual = document.getElementById('input-visual');
        const valVisual = document.getElementById('val-visual');
        const inputFade = document.getElementById('input-fade');
        const valFade = document.getElementById('val-fade');

        // --- 変数 (初期設定) ---
        let lastFrameData = null;
        let visualMotion = 0;
        let lastAccel = { x:0, y:0, z:0 };
        let vehicleVibration = 0;
        
        // 設定値 (可変)
        let VISUAL_THRESHOLD = 15.0; 
        let VIBE_THRESHOLD = 0.5;
        let FADE_DURATION = 0.5;

        // --- 設定反映ロジック ---
        function updateSettings() {
            // 閾値更新
            VISUAL_THRESHOLD = parseFloat(inputVisual.value);
            valVisual.innerText = VISUAL_THRESHOLD.toFixed(1);

            // フェード時間更新
            FADE_DURATION = parseFloat(inputFade.value);
            valFade.innerText = FADE_DURATION.toFixed(1) + 's';
            
            // CSS Transitionを動的に書き換え
            globalWarning.style.transition = `opacity ${FADE_DURATION}s`;
        }

        // イベントリスナー
        inputVisual.addEventListener('input', updateSettings);
        inputFade.addEventListener('input', updateSettings);
        
        // モーダル開閉
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // ドラッグ開始を防ぐ
            settingsModal.style.display = 'flex';
        });
        
        // モーダルを閉じる (タッチイベントの伝播を防ぐ)
        const closeModal = (e) => {
            if(e) e.stopPropagation();
            settingsModal.style.display = 'none';
        };
        closeSettingsBtn.addEventListener('click', closeModal);
        // 背景クリックでも閉じる
        settingsModal.addEventListener('click', (e) => {
            if(e.target === settingsModal) closeModal();
        });


        // --- 1. ドラッグ移動ロジック (ウィンドウ全体) ---
        let isDragging = false;
        let dragOffsetX, dragOffsetY;

        win.addEventListener('touchstart', (e) => {
            // リサイズハンドルや設定ボタンを触っていたらドラッグしない
            if (e.target === resizer || e.target === settingsBtn) return;

            isDragging = true;
            const touch = e.touches[0];
            const rect = win.getBoundingClientRect();
            dragOffsetX = touch.clientX - rect.left;
            dragOffsetY = touch.clientY - rect.top;
            e.preventDefault(); 
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const touch = e.touches[0];
            
            let newLeft = touch.clientX - dragOffsetX;
            let newTop = touch.clientY - dragOffsetY;

            win.style.left = `${newLeft}px`;
            win.style.top = `${newTop}px`;
            e.preventDefault();
        }, {passive: false});

        document.addEventListener('touchend', () => isDragging = false);


        // --- 2. リサイズロジック ---
        let isResizing = false;
        let initialWidth, initialHeight, initialTouchX, initialTouchY;

        resizer.addEventListener('touchstart', (e) => {
            isResizing = true;
            e.stopPropagation();
            const touch = e.touches[0];
            initialTouchX = touch.clientX;
            initialTouchY = touch.clientY;
            initialWidth = win.offsetWidth;
            initialHeight = win.offsetHeight;
            e.preventDefault();
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            if (!isResizing) return;
            const touch = e.touches[0];
            const dx = touch.clientX - initialTouchX;
            const dy = touch.clientY - initialTouchY;
            
            const newW = Math.max(100, initialWidth + dx);
            const newH = Math.max(80, initialHeight + dy);

            win.style.width = `${newW}px`;
            win.style.height = `${newH}px`;
            e.preventDefault();
        }, {passive: false});

        document.addEventListener('touchend', () => isResizing = false);


        // --- 3. アプリケーション開始 ---
        startBtn.addEventListener('click', async () => {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try { await DeviceMotionEvent.requestPermission(); } catch (e) {}
            }
            startOverlay.style.display = 'none';
            // 初期設定を適用
            updateSettings();
            
            startCamera();
            startSensor();
            setInterval(processImage, 200);
        });

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' },
                    audio: false 
                });
                video.srcObject = stream;
            } catch (err) {
                alert("カメラエラー: " + err);
            }
        }

        function startSensor() {
            window.addEventListener('devicemotion', (event) => {
                const acc = event.acceleration;
                if(!acc) return;
                const dx = Math.abs(acc.x - lastAccel.x);
                const dy = Math.abs(acc.y - lastAccel.y);
                const dz = Math.abs(acc.z - lastAccel.z);
                vehicleVibration = (dx + dy + dz);
                lastAccel = { x: acc.x, y: acc.y, z: acc.z };
            });
        }

        // --- 4. 判定ロジック & UI更新 ---
        function processImage() {
            if (video.readyState !== 4) return;
            canvas.width = 32; canvas.height = 32;
            ctx.drawImage(video, 0, 0, 32, 32);
            
            const frame = ctx.getImageData(0, 0, 32, 32);
            const data = frame.data;
            let diffSum = 0;

            if (lastFrameData) {
                for (let i = 0; i < data.length; i += 4) {
                    diffSum += Math.abs(data[i+1] - lastFrameData[i+1]);
                }
                visualMotion = diffSum / (data.length / 4);
            }
            lastFrameData = new Uint8ClampedArray(data);

            updateUI();
        }

        function updateUI() {
            const isSceneryMoving = visualMotion > VISUAL_THRESHOLD;
            const isShaking = vehicleVibration > VIBE_THRESHOLD;

            // 警告判定
            if (isSceneryMoving) {
                globalWarning.style.opacity = 1;
                win.style.borderColor = "red";
                win.style.boxShadow = "0 0 30px red";
            } else {
                globalWarning.style.opacity = 0;
                win.style.borderColor = "#666";
                win.style.boxShadow = "0 0 15px rgba(255,255,255,0.1)";
            }
            
            debugInfo.innerText = `Vis:${visualMotion.toFixed(1)} / Thr:${VISUAL_THRESHOLD}`;
        }
    </script>
</body>
</html>
